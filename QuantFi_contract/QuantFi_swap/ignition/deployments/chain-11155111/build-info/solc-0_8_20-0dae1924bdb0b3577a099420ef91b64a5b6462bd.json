{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-0dae1924bdb0b3577a099420ef91b64a5b6462bd",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/dex/uniswap/UniswapV3Router.sol": "project/contracts/dex/uniswap/UniswapV3Router.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "npm/@uniswap/swap-router-contracts@1.3.1/:@uniswap/v3-core/=npm/@uniswap/v3-core@1.0.1/",
        "npm/@uniswap/swap-router-contracts@1.3.1/:@uniswap/v3-periphery/=npm/@uniswap/v3-periphery@1.4.4/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@uniswap/swap-router-contracts/=npm/@uniswap/swap-router-contracts@1.3.1/",
        "project/:@uniswap/swap-router-contracts/=npm/@uniswap/swap-router-contracts@1.3.1/",
        "project/:@uniswap/swap-router-contracts/=npm/@uniswap/swap-router-contracts@1.3.1/",
        "project/:@uniswap/swap-router-contracts/=npm/@uniswap/swap-router-contracts@1.3.1/",
        "project/:@uniswap/v3-core/=npm/@uniswap/v3-core@1.0.1/",
        "project/:@uniswap/v3-periphery/=npm/@uniswap/v3-periphery@1.4.4/",
        "project/:@uniswap/v3-periphery/=npm/@uniswap/v3-periphery@1.4.4/"
      ],
      "viaIR": true
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
      },
      "npm/@uniswap/swap-router-contracts@1.3.1/contracts/interfaces/IMulticallExtended.sol": {
        "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@uniswap/v3-periphery/contracts/interfaces/IMulticall.sol';\n\n/// @title MulticallExtended interface\n/// @notice Enables calling multiple methods in a single call to the contract with optional validation\ninterface IMulticallExtended is IMulticall {\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n    /// @dev The `msg.value` should not be trusted for any method callable from multicall.\n    /// @param deadline The time by which this function must be called before failing\n    /// @param data The encoded function data for each of the calls to make to this contract\n    /// @return results The results from each of the calls passed in via data\n    function multicall(uint256 deadline, bytes[] calldata data) external payable returns (bytes[] memory results);\n\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n    /// @dev The `msg.value` should not be trusted for any method callable from multicall.\n    /// @param previousBlockhash The expected parent blockHash\n    /// @param data The encoded function data for each of the calls to make to this contract\n    /// @return results The results from each of the calls passed in via data\n    function multicall(bytes32 previousBlockhash, bytes[] calldata data)\n        external\n        payable\n        returns (bytes[] memory results);\n}\n"
      },
      "npm/@uniswap/swap-router-contracts@1.3.1/contracts/interfaces/IV2SwapRouter.sol": {
        "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V2\ninterface IV2SwapRouter {\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\n    /// and swap the entire amount, enabling contracts to send tokens before calling this function.\n    /// @param amountIn The amount of token to swap\n    /// @param amountOutMin The minimum amount of output that must be received\n    /// @param path The ordered list of tokens to swap through\n    /// @param to The recipient address\n    /// @return amountOut The amount of the received token\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to\n    ) external payable returns (uint256 amountOut);\n\n    /// @notice Swaps as little as possible of one token for an exact amount of another token\n    /// @param amountOut The amount of token to swap for\n    /// @param amountInMax The maximum amount of input that the caller will pay\n    /// @param path The ordered list of tokens to swap through\n    /// @param to The recipient address\n    /// @return amountIn The amount of token to pay\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to\n    ) external payable returns (uint256 amountIn);\n}\n"
      },
      "npm/@uniswap/swap-router-contracts@1.3.1/contracts/interfaces/IV3SwapRouter.sol": {
        "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface IV3SwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\n    /// and swap the entire amount, enabling contracts to send tokens before calling this function.\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @dev Setting `amountIn` to 0 will cause the contract to look up its own balance,\n    /// and swap the entire amount, enabling contracts to send tokens before calling this function.\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// that may remain in the router after the swap.\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// that may remain in the router after the swap.\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
      },
      "npm/@uniswap/v3-core@1.0.1/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {
        "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
      },
      "npm/@uniswap/v3-core@1.0.1/contracts/interfaces/IUniswapV3Factory.sol": {
        "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title The interface for the Uniswap V3 Factory\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\ninterface IUniswapV3Factory {\n    /// @notice Emitted when the owner of the factory is changed\n    /// @param oldOwner The owner before the owner was changed\n    /// @param newOwner The owner after the owner was changed\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    /// @notice Emitted when a pool is created\n    /// @param token0 The first token of the pool by address sort order\n    /// @param token1 The second token of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param pool The address of the created pool\n    event PoolCreated(\n        address indexed token0,\n        address indexed token1,\n        uint24 indexed fee,\n        int24 tickSpacing,\n        address pool\n    );\n\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\n    /// @param fee The enabled fee, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\n\n    /// @notice Returns the current owner of the factory\n    /// @dev Can be changed by the current owner via setOwner\n    /// @return The address of the factory owner\n    function owner() external view returns (address);\n\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\n    /// @return The tick spacing\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\n\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n    /// @param tokenA The contract address of either token0 or token1\n    /// @param tokenB The contract address of the other token\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @return pool The pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (address pool);\n\n    /// @notice Creates a pool for the given two tokens and fee\n    /// @param tokenA One of the two tokens in the desired pool\n    /// @param tokenB The other of the two tokens in the desired pool\n    /// @param fee The desired fee for the pool\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\n    /// are invalid.\n    /// @return pool The address of the newly created pool\n    function createPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external returns (address pool);\n\n    /// @notice Updates the owner of the factory\n    /// @dev Must be called by the current owner\n    /// @param _owner The new owner of the factory\n    function setOwner(address _owner) external;\n\n    /// @notice Enables a fee amount with the given tickSpacing\n    /// @dev Fee amounts may never be removed once enabled\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\n}\n"
      },
      "npm/@uniswap/v3-periphery@1.4.4/contracts/interfaces/IMulticall.sol": {
        "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Multicall interface\n/// @notice Enables calling multiple methods in a single call to the contract\ninterface IMulticall {\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n    /// @dev The `msg.value` should not be trusted for any method callable from multicall.\n    /// @param data The encoded function data for each of the calls to make to this contract\n    /// @return results The results from each of the calls passed in via data\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n}\n"
      },
      "npm/@uniswap/v3-periphery@1.4.4/contracts/interfaces/IQuoterV2.sol": {
        "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title QuoterV2 Interface\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps.\n/// @notice For each pool also tells you the number of initialized ticks crossed and the sqrt price of the pool after the swap.\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\ninterface IQuoterV2 {\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\n    /// @param amountIn The amount of the first token to swap\n    /// @return amountOut The amount of the last token that would be received\n    /// @return sqrtPriceX96AfterList List of the sqrt price after the swap for each pool in the path\n    /// @return initializedTicksCrossedList List of the initialized ticks that the swap crossed for each pool in the path\n    /// @return gasEstimate The estimate of the gas that the swap consumes\n    function quoteExactInput(bytes memory path, uint256 amountIn)\n        external\n        returns (\n            uint256 amountOut,\n            uint160[] memory sqrtPriceX96AfterList,\n            uint32[] memory initializedTicksCrossedList,\n            uint256 gasEstimate\n        );\n\n    struct QuoteExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint256 amountIn;\n        uint24 fee;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\n    /// @param params The params for the quote, encoded as `QuoteExactInputSingleParams`\n    /// tokenIn The token being swapped in\n    /// tokenOut The token being swapped out\n    /// fee The fee of the token pool to consider for the pair\n    /// amountIn The desired input amount\n    /// sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountOut The amount of `tokenOut` that would be received\n    /// @return sqrtPriceX96After The sqrt price of the pool after the swap\n    /// @return initializedTicksCrossed The number of initialized ticks that the swap crossed\n    /// @return gasEstimate The estimate of the gas that the swap consumes\n    function quoteExactInputSingle(QuoteExactInputSingleParams memory params)\n        external\n        returns (\n            uint256 amountOut,\n            uint160 sqrtPriceX96After,\n            uint32 initializedTicksCrossed,\n            uint256 gasEstimate\n        );\n\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\n    /// @param amountOut The amount of the last token to receive\n    /// @return amountIn The amount of first token required to be paid\n    /// @return sqrtPriceX96AfterList List of the sqrt price after the swap for each pool in the path\n    /// @return initializedTicksCrossedList List of the initialized ticks that the swap crossed for each pool in the path\n    /// @return gasEstimate The estimate of the gas that the swap consumes\n    function quoteExactOutput(bytes memory path, uint256 amountOut)\n        external\n        returns (\n            uint256 amountIn,\n            uint160[] memory sqrtPriceX96AfterList,\n            uint32[] memory initializedTicksCrossedList,\n            uint256 gasEstimate\n        );\n\n    struct QuoteExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint256 amount;\n        uint24 fee;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\n    /// @param params The params for the quote, encoded as `QuoteExactOutputSingleParams`\n    /// tokenIn The token being swapped in\n    /// tokenOut The token being swapped out\n    /// fee The fee of the token pool to consider for the pair\n    /// amountOut The desired output amount\n    /// sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\n    /// @return sqrtPriceX96After The sqrt price of the pool after the swap\n    /// @return initializedTicksCrossed The number of initialized ticks that the swap crossed\n    /// @return gasEstimate The estimate of the gas that the swap consumes\n    function quoteExactOutputSingle(QuoteExactOutputSingleParams memory params)\n        external\n        returns (\n            uint256 amountIn,\n            uint160 sqrtPriceX96After,\n            uint32 initializedTicksCrossed,\n            uint256 gasEstimate\n        );\n}\n"
      },
      "npm/@uniswap/v3-periphery@1.4.4/contracts/interfaces/ISelfPermit.sol": {
        "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\n\n/// @title Self Permit\n/// @notice Functionality to call permit on any EIP-2612-compliant token for use in the route\ninterface ISelfPermit {\n    /// @notice Permits this contract to spend a given token from `msg.sender`\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this).\n    /// @param token The address of the token spent\n    /// @param value The amount that can be spent of token\n    /// @param deadline A timestamp, the current blocktime must be less than or equal to this timestamp\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function selfPermit(\n        address token,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n\n    /// @notice Permits this contract to spend a given token from `msg.sender`\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this).\n    /// Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit\n    /// @param token The address of the token spent\n    /// @param value The amount that can be spent of token\n    /// @param deadline A timestamp, the current blocktime must be less than or equal to this timestamp\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function selfPermitIfNecessary(\n        address token,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n\n    /// @notice Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this)\n    /// @param token The address of the token spent\n    /// @param nonce The current nonce of the owner\n    /// @param expiry The timestamp at which the permit is no longer valid\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function selfPermitAllowed(\n        address token,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n\n    /// @notice Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this)\n    /// Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.\n    /// @param token The address of the token spent\n    /// @param nonce The current nonce of the owner\n    /// @param expiry The timestamp at which the permit is no longer valid\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function selfPermitAllowedIfNecessary(\n        address token,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n}\n"
      },
      "project/contracts/dex/uniswap/interface/ISwapRouter02.sol": {
        "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.7.5;\r\npragma abicoder v2;\r\n\r\nimport '@uniswap/v3-periphery/contracts/interfaces/ISelfPermit.sol';\r\n\r\nimport '@uniswap/swap-router-contracts/contracts/interfaces/IV2SwapRouter.sol';\r\nimport '@uniswap/swap-router-contracts/contracts/interfaces/IV3SwapRouter.sol';\r\nimport '@uniswap/swap-router-contracts/contracts/interfaces/IMulticallExtended.sol';\r\n\r\ninterface IApproveAndCall {\r\n    enum ApprovalType {NOT_REQUIRED, MAX, MAX_MINUS_ONE, ZERO_THEN_MAX, ZERO_THEN_MAX_MINUS_ONE}\r\n\r\n    /// @dev Lens to be called off-chain to determine which (if any) of the relevant approval functions should be called\r\n    /// @param token The token to approve\r\n    /// @param amount The amount to approve\r\n    /// @return The required approval type\r\n    function getApprovalType(address token, uint256 amount) external returns (ApprovalType);\r\n\r\n    /// @notice Approves a token for the maximum possible amount\r\n    /// @param token The token to approve\r\n    function approveMax(address token) external payable;\r\n\r\n    /// @notice Approves a token for the maximum possible amount minus one\r\n    /// @param token The token to approve\r\n    function approveMaxMinusOne(address token) external payable;\r\n\r\n    /// @notice Approves a token for zero, then the maximum possible amount\r\n    /// @param token The token to approve\r\n    function approveZeroThenMax(address token) external payable;\r\n\r\n    /// @notice Approves a token for zero, then the maximum possible amount minus one\r\n    /// @param token The token to approve\r\n    function approveZeroThenMaxMinusOne(address token) external payable;\r\n\r\n    /// @notice Calls the position manager with arbitrary calldata\r\n    /// @param data Calldata to pass along to the position manager\r\n    /// @return result The result from the call\r\n    function callPositionManager(bytes memory data) external payable returns (bytes memory result);\r\n\r\n    struct MintParams {\r\n        address token0;\r\n        address token1;\r\n        uint24 fee;\r\n        int24 tickLower;\r\n        int24 tickUpper;\r\n        uint256 amount0Min;\r\n        uint256 amount1Min;\r\n        address recipient;\r\n    }\r\n\r\n    /// @notice Calls the position manager's mint function\r\n    /// @param params Calldata to pass along to the position manager\r\n    /// @return result The result from the call\r\n    function mint(MintParams calldata params) external payable returns (bytes memory result);\r\n\r\n    struct IncreaseLiquidityParams {\r\n        address token0;\r\n        address token1;\r\n        uint256 tokenId;\r\n        uint256 amount0Min;\r\n        uint256 amount1Min;\r\n    }\r\n\r\n    /// @notice Calls the position manager's increaseLiquidity function\r\n    /// @param params Calldata to pass along to the position manager\r\n    /// @return result The result from the call\r\n    function increaseLiquidity(IncreaseLiquidityParams calldata params) external payable returns (bytes memory result);\r\n}\r\n\r\n/// @title Router token swapping functionality\r\ninterface ISwapRouter02 is IV2SwapRouter, IV3SwapRouter, IApproveAndCall, IMulticallExtended, ISelfPermit {\r\n\r\n}\r\n\r\n\r\n"
      },
      "project/contracts/dex/uniswap/UniswapV3Router.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"../../IDexRouter.sol\";\r\nimport \"../../lib/Model.sol\";\r\nimport \"./interface/ISwapRouter02.sol\";\r\nimport \"@uniswap/swap-router-contracts/contracts/interfaces/IV3SwapRouter.sol\";\r\nimport \"@uniswap/v3-periphery/contracts/interfaces/IQuoterV2.sol\";\r\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\n\r\ninterface WETH9Token {\r\n    function deposit() external payable;\r\n    function withdraw(uint wad) external;\r\n}\r\n\r\n/**\r\n * @title UniswapV3Router\r\n * @dev 实现IDexRouter接口的Uniswap V3路由器合约\r\n */\r\ncontract UniswapV3Router is IDexRouter, Ownable, ReentrancyGuard {\r\n    // Uniswap V3路由器地址\r\n    ISwapRouter02 public immutable swapRouter;\r\n\r\n    // Uniswap V3 Quoter地址\r\n    IQuoterV2 public immutable quoter;\r\n\r\n    // Uniswap V3工厂地址\r\n    IUniswapV3Factory public immutable factory;\r\n\r\n    WETH9Token public immutable WETH9;\r\n\r\n    // 支持交换的tokens\r\n    address[] public exchangeableTokens;\r\n\r\n    // 支持的费用层级 (代币对 => 对应的池信息)\r\n    mapping(address token0 => mapping(address token1 => uint24 fee)) public feeTiers;\r\n\r\n \r\n    // 事件\r\n    event SwapTokensForTokens(uint256 amountIn, uint256 amountOut, address to);\r\n    event SetFeeTier(address tokenA, address tokenB, uint24 fee);\r\n    event AddExchangeableToken(address token);\r\n    event RemoveExchangeableToken(address token);\r\n\r\n    constructor(\r\n        address _swapRouter,\r\n        address _quoter,\r\n        address _factory,\r\n        address _owner,\r\n        address _WETH9,\r\n        address[] memory _exchangeableTokens\r\n    ) Ownable(_owner) {\r\n        require(_exchangeableTokens.length > 1, \"UniswapV3Router: INVALID_TOKENS_LENGTH\");\r\n        require(_swapRouter != address(0), \"UniswapV3Router: INVALID_ROUTER\");\r\n        require(_quoter != address(0), \"UniswapV3Router: INVALID_QUOTER\");\r\n        require(_factory != address(0), \"UniswapV3Router: INVALID_FACTORY\");\r\n        require(_owner != address(0), \"UniswapV3Router: INVALID_OWNER\");\r\n        quoter = IQuoterV2(_quoter);\r\n        swapRouter = ISwapRouter02(_swapRouter);\r\n        factory = IUniswapV3Factory(_factory);\r\n        WETH9 = WETH9Token(_WETH9);\r\n        exchangeableTokens = _exchangeableTokens;\r\n    }\r\n\r\n    /**\r\n     * @dev 添加可交换的代币\r\n     * @param token 代币地址\r\n     */\r\n    function addExchangeableToken(address token) public onlyOwner {\r\n        require(token != address(0), \"UniswapV3Router: INVALID_TOKEN\");\r\n        bool exists = false;\r\n        for (uint256 i = 0; i < exchangeableTokens.length; i++) {\r\n            if (exchangeableTokens[i] == token) {\r\n                exists = true;\r\n                break;\r\n            }\r\n        }\r\n        require(!exists, \"UniswapV3Router: TOKEN_ALREADY_EXIST\");\r\n        exchangeableTokens.push(token);\r\n        emit AddExchangeableToken(token);\r\n    }\r\n\r\n    /**\r\n     * @dev 移除可交换的代币\r\n     * @param token 代币地址\r\n     */\r\n    function removeExchangeableToken(address token) public onlyOwner {\r\n        uint256 length = exchangeableTokens.length; // 获取数组长度\r\n        for (uint256 i = 0; i < length; i++) {\r\n            if (exchangeableTokens[i] == token) {\r\n                // 将最后一个元素移动到当前位置\r\n                exchangeableTokens[i] = exchangeableTokens[length - 1];\r\n                // 删除最后一个元素\r\n                exchangeableTokens.pop();\r\n                emit RemoveExchangeableToken(token);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getAllExchangeableTokens() public view returns (address[] memory) {\r\n        return exchangeableTokens;\r\n    }\r\n\r\n    /**\r\n     * @dev 设置代币对的费用层级\r\n     * @param tokenA 代币A地址\r\n     * @param tokenB 代币B地址\r\n     * @param fee 费用层级 500, 3000, 10000\r\n     */\r\n    function setFeeTier(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint24 fee\r\n    ) public onlyOwner {\r\n        address poolAddress = factory.getPool(tokenA, tokenB, fee);\r\n        require(poolAddress != address(0), \"UniswapV3Router: POOL_NOT_EXIST\");\r\n        feeTiers[tokenA][tokenB] = fee;\r\n        feeTiers[tokenB][tokenA] = fee;\r\n        emit SetFeeTier(tokenA, tokenB, fee);\r\n    }\r\n\r\n    /**\r\n     * @dev 实现IDexRouter.swapTokensForTokens\r\n     * 根据给定路径将精确数量的输入代币交换为输出代币\r\n     */\r\n    function swapTokensForTokens(\r\n        Model.SwapPath memory swapPath,\r\n        address tokenIn,\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable override nonReentrant returns (uint256) {\r\n        require(deadline >= block.timestamp, \"UniswapV3Router: EXPIRED\");\r\n        require(swapPath.path.length >= 2, \"UniswapV3Router: INVALID_PATH\");\r\n\r\n        if (tokenIn == address(0) || tokenIn == address(WETH9)) {\r\n            require(msg.value > 0, \"UniswapV3Router: INSUFFICIENT_ETH_SENT\");\r\n            // ETH 转 WETH\r\n            WETH9.deposit{value: msg.value}();\r\n            amountIn = msg.value;\r\n            tokenIn = address(WETH9);\r\n        } else {\r\n            // 将代币转入本合约\r\n            IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn);\r\n        }\r\n\r\n        // 批准路由器使用代币\r\n        IERC20(tokenIn).approve(address(swapRouter), amountIn);\r\n        // 设置交换参数\r\n        IV3SwapRouter.ExactInputParams memory params = IV3SwapRouter\r\n            .ExactInputParams({\r\n                path: swapPath.pathBytes,\r\n                recipient: to,\r\n                amountIn: amountIn,\r\n                amountOutMinimum: amountOutMin\r\n            });\r\n\r\n        // 执行交换\r\n        uint256 amountOut = swapRouter.exactInput(params);\r\n        emit SwapTokensForTokens(amountIn, amountOut, to);\r\n        return amountOut;\r\n    }\r\n\r\n    /**\r\n     * @dev 实现IDexRouter.getAmountsOut\r\n     * 返回给定输入数量的最优输出数量、路径\r\n     */\r\n    function getAmountsOut(\r\n        address tokenIn,\r\n        uint256 amountIn,\r\n        address tokenOut,\r\n        uint8 maxHops\r\n    ) external override returns (Model.SwapPath memory swapPath) {\r\n        if (tokenIn == address(0)) {\r\n            tokenIn = address(WETH9);\r\n        }\r\n        swapPath.inputAmount = amountIn;\r\n        swapPath.dexRouter = address(this);\r\n        // 所有路径组合\r\n        uint256 totalCombinations = _calculateTotalCombinations(exchangeableTokens.length - 1);\r\n        address[][] memory pathRecord = new address[][](totalCombinations);\r\n\r\n        uint256 resultIndex = 0;\r\n        address[] memory directExchange = new address[](2);\r\n        directExchange[0] = tokenIn;\r\n        directExchange[1] = tokenOut;\r\n        pathRecord[resultIndex] = directExchange;\r\n\r\n        uint24 fee = feeTiers[tokenIn][tokenOut];\r\n        // require(fee != 0, \"UniswapV3Router: NO_FEE_TIER_SET\");\r\n        if (fee != 0) {\r\n            bytes memory path = abi.encodePacked(tokenIn, fee, tokenOut);\r\n            (uint256 amountOut, , , ) = getAmountOutMulti(path, swapPath.inputAmount);\r\n            swapPath.outputAmount = amountOut;\r\n            swapPath.pathBytes = path;\r\n            swapPath.path = pathRecord[resultIndex];\r\n        }\r\n        resultIndex++;\r\n\r\n        for (uint256 length = 2; length <= maxHops; length++) {\r\n            if (exchangeableTokens.length < length - 1) continue; // 没有足够的元素\r\n\r\n            uint256[] memory used = new uint256[](exchangeableTokens.length);\r\n            address[] memory combination = new address[](length + 1);\r\n            combination[0] = tokenIn;\r\n            resultIndex = _generatePermutations(\r\n                tokenIn,\r\n                combination,\r\n                1,\r\n                used,\r\n                pathRecord,\r\n                resultIndex,\r\n                tokenOut,\r\n                swapPath\r\n            );\r\n        }\r\n        return swapPath;\r\n    }\r\n\r\n    // 查询币对价格\r\n    function getAmountOutSingle(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint24 fee,\r\n        uint256 amountIn,\r\n        uint160 sqrtPriceLimitX96\r\n    ) public returns (uint256, uint160, uint32, uint256) {\r\n        try\r\n            quoter.quoteExactInputSingle(\r\n                IQuoterV2.QuoteExactInputSingleParams({\r\n                    tokenIn: tokenIn,\r\n                    tokenOut: tokenOut,\r\n                    amountIn: amountIn,\r\n                    fee: fee,\r\n                    sqrtPriceLimitX96: sqrtPriceLimitX96\r\n                })\r\n            )\r\n        returns (\r\n            uint256 amountOut,\r\n            uint160 sqrtPriceX96After,\r\n            uint32 initializedTicksCrossed,\r\n            uint256 gasEstimate\r\n        ) {\r\n            return (\r\n                amountOut,\r\n                sqrtPriceX96After,\r\n                initializedTicksCrossed,\r\n                gasEstimate\r\n            );\r\n        } catch {\r\n            // 如果查询失败，返回零\r\n            return (0, 0, 0, 0);\r\n        }\r\n    }\r\n\r\n    // 查询多币对价格\r\n    function getAmountOutMulti(\r\n        bytes memory path,\r\n        uint256 amountIn\r\n    ) public returns (uint256, uint160[] memory, uint32[] memory, uint256) {\r\n        try quoter.quoteExactInput(path, amountIn) returns (\r\n            uint256 amountOut,\r\n            uint160[] memory sqrtPriceX96AfterList,\r\n            uint32[] memory initializedTicksCrossedList,\r\n            uint256 gasEstimate\r\n        ) {\r\n            return (\r\n                amountOut,\r\n                sqrtPriceX96AfterList,\r\n                initializedTicksCrossedList,\r\n                gasEstimate\r\n            );\r\n        } catch {\r\n            // 如果查询失败，返回零\r\n            return (0, new uint160[](0), new uint32[](0), 0);\r\n        }\r\n    }\r\n\r\n    // 计算组合总数\r\n    function _calculateTotalCombinations(uint256 n) private pure returns (uint256) {\r\n        if (n == 0) return 1; // 只有长度为1的组合\r\n\r\n        uint256 total = 1; // 长度为1\r\n        uint256 currentPermutation = 1;\r\n\r\n        for (uint256 k = 1; k <= n; k++) {\r\n            currentPermutation *= (n - (k - 1));\r\n            total += currentPermutation;\r\n        }\r\n\r\n        return total;\r\n    }\r\n\r\n    // 递归生成排列\r\n    function _generatePermutations(\r\n        address tokenIn,\r\n        address[] memory combination,\r\n        uint256 depth,\r\n        uint256[] memory used,\r\n        address[][] memory pathRecord,\r\n        uint256 resultIndex,\r\n        address tokenOut,\r\n        Model.SwapPath memory swapPath\r\n    ) private returns (uint256) {\r\n        // 达到目标长度，保存组合\r\n        if (depth == combination.length - 1) {\r\n            combination[depth] = tokenOut;\r\n            pathRecord[resultIndex] = new address[](combination.length);\r\n            bytes memory path = new bytes(0);\r\n            for (uint256 i = 0; i < combination.length; i++) {\r\n                pathRecord[resultIndex][i] = combination[i];\r\n                if (i > 0) {\r\n                    uint24 fee = feeTiers[combination[i - 1]][combination[i]];\r\n                    if (fee == 0) {\r\n                        return resultIndex + 1;\r\n                    }\r\n                    // require(fee != 0, \"UniswapV3Router: NO_FEE_TIER_SET\");\r\n                    path = bytes.concat(path, abi.encodePacked(uint24(fee), combination[i]));\r\n                } else {\r\n                    path = bytes.concat(path, abi.encodePacked(combination[i]));\r\n                }\r\n            }\r\n\r\n            (uint256 amountOut, , , ) = getAmountOutMulti(path, swapPath.inputAmount);\r\n            if (amountOut > swapPath.outputAmount) {\r\n                swapPath.outputAmount = amountOut;\r\n                swapPath.path = pathRecord[resultIndex];\r\n                swapPath.pathBytes = path;\r\n            }\r\n\r\n            return resultIndex + 1;\r\n        }\r\n\r\n        // 遍历所有元素\r\n        for (uint256 i = 0; i < exchangeableTokens.length; i++) {\r\n            // 跳过tokenIn和已使用的元素\r\n            if (exchangeableTokens[i] == tokenIn || used[i] > 0) continue;\r\n\r\n            // 标记为已使用\r\n            used[i] = 1;\r\n\r\n            // 添加到组合\r\n            combination[depth] = exchangeableTokens[i];\r\n\r\n            // 递归生成下一层\r\n            resultIndex = _generatePermutations(\r\n                tokenIn,\r\n                combination,\r\n                depth + 1,\r\n                used,\r\n                pathRecord,\r\n                resultIndex,\r\n                tokenOut,\r\n                swapPath\r\n            );\r\n\r\n            // 回溯\r\n            used[i] = 0;\r\n        }\r\n\r\n        return resultIndex;\r\n    }\r\n\r\n    /**\r\n     * @dev 实现IDexRouter.dexName\r\n     * 返回DEX的名称\r\n     */\r\n    function dexName() external pure override returns (string memory) {\r\n        return \"UniswapV3\";\r\n    }\r\n}\r\n"
      },
      "project/contracts/IDexRouter.sol": {
        "content": "\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./lib/Model.sol\";\n\n/**\n * @title IDexRouter\n * @dev 可插入我们交换合约的DEX路由器接口\n */\ninterface IDexRouter {\n    /**\n     * @dev 将精确数量的输入代币交换为输出代币\n     * @param path 定义路由的代币地址数组\n     * @param tokenIn 输入代币地址\n     * @param amountIn 要发送的输入代币数量\n     * @param amountOutMin 要接收的输出代币最小数量\n     * @param to 输出代币的接收者\n     * @param deadline 交易将回滚的Unix时间戳\n     * @return amount 输入代币数量和所有后续输出代币数量\n     */\n    function swapTokensForTokens(\n        Model.SwapPath memory path,\n        address tokenIn,\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256 amount);\n\n    /**\n     * @dev 返回给定输入数量的最佳输出代币数量，以及交换路径\n     * @param tokenIn 输入代币地址\n     * @param amountIn 输入代币数量\n     * @param tokenOut 输出代币地址\n     * @param maxHops 最大跳数\n     * @return path 包含最佳路径和输出数量的SwapPath结构体\n     */\n    function getAmountsOut(address tokenIn, uint256 amountIn, \n                address tokenOut, uint8 maxHops) external returns (Model.SwapPath memory path);\n\n    /**\n     * @dev 返回DEX的名称\n     * @return DEX的名称\n     */\n    function dexName() external pure returns (string memory);\n}\n"
      },
      "project/contracts/lib/Model.sol": {
        "content": "// SPDX-License-Identifier: MIT \npragma solidity ^0.8.20;\n\nlibrary Model {\n    // 存储潜在交换路径的结构体\n    struct SwapPath {\n        address[] path; // 代币地址数组表示的路径\n        bytes pathBytes; // 路径字节表示\n        uint256 outputAmount; // 输出金额\n        uint256 inputAmount; // 输入金额\n        address dexRouter; // 交易所路由地址\n    }\n\n}"
      }
    }
  }
}